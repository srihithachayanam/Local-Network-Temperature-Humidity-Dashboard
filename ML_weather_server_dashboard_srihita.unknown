ML Features Implemented:
1. Predictive Analytics

Linear Regression for temperature & humidity trends
1-hour ahead predictions based on historical patterns
Trend visualization (rising/falling/stable)

2. Anomaly Detection

Z-score method to detect unusual spikes
Alerts when readings deviate >2.5 standard deviations
Real-time anomaly notifications

3. Comfort Index Algorithm

Heat Index calculation (feels-like temperature)
Optimal range analysis (20-26¬∞C, 40-60% humidity)
Visual comfort score (0-100) with color-coded bar

4. Statistical Analysis

Running mean & standard deviation
Data collection (stores last 100 samples)
Pattern recognition over time

How It Works:
Data Collection:

Collects samples every 2 seconds
Stores 100 most recent readings
Analyzes patterns after 10+ samples

ML Algorithms:

Linear Regression: Calculates temperature/humidity rate of change
Z-Score Anomaly Detection: Identifies outliers automatically
Comfort Scoring: Multi-factor analysis of ideal conditions

Predictions:

Uses trend slopes to forecast 1 hour ahead
Updates in real-time as new data arrives
More accurate after 20+ samples

What You'll See:
üìä Real-time trends (e.g., "+0.5¬∞C/hour")
üîÆ Future predictions (temperature in 1 hour)
‚ö†Ô∏è Anomaly alerts when unusual changes occur
üòä Comfort score (0-100) with visual bar
üìà Statistical insights (mean, std dev, samples)
The ML runs entirely on the ESP32 - no cloud needed! It learns your environment's patterns and alerts you to unusual conditions automatically.


####3 How to connect #####
turn on phone hotspot 
set name as "circuitX"
password"1029384756"
connect the dashboard viewing device ie phone laptop to same phone hotspot 
 now we must see 2 devices connected ie  our esp32 and viewing decice 
     


=== FINAL CONNECTION INFO ===
Access dashboard at: http://10.49.99.100
============================
+++++++++++++++++++++++CODE++++++++++++++++++++++++++++++


#include <WiFi.h>
#include <WebServer.h>
#include <DHT.h>

// DHT Sensor Configuration
#define DHTPIN 13
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// WiFi Credentials
const char* ssid = "circuitX";
const char* password = "1029384756";

bool useStaticIP = true;

WebServer server(80);

// Sensor Variables
float temp = 0;
float hum = 0;

// ML - Data Collection
#define MAX_SAMPLES 100
float tempHistory[MAX_SAMPLES];
float humHistory[MAX_SAMPLES];
unsigned long timeHistory[MAX_SAMPLES];
int sampleIndex = 0;
int totalSamples = 0;

// ML - Statistics & Predictions
float tempMean = 0, tempStdDev = 0;
float humMean = 0, humStdDev = 0;
float tempTrend = 0;  // ¬∞C per hour
float humTrend = 0;   // % per hour
float tempPrediction1h = 0;
float humPrediction1h = 0;

// ML - Anomaly Detection
bool tempAnomaly = false;
bool humAnomaly = false;
String anomalyMessage = "";

// ML - Comfort Index
String comfortLevel = "Calculating...";
int comfortScore = 0;

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n=== ESP32 ML Climate Monitor ===");
  
  dht.begin();
  
  // Connect to WiFi
  WiFi.begin(ssid, password);
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 40) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("\n‚úó Connection failed!");
    return;
  }
  
  Serial.println("\n‚úì Connected!");
  Serial.print("DHCP IP: ");
  Serial.println(WiFi.localIP());
  
  if (useStaticIP) {
    IPAddress gateway = WiFi.gatewayIP();
    IPAddress subnet = WiFi.subnetMask();
    IPAddress dns = WiFi.dnsIP();
    IPAddress staticIP = gateway;
    staticIP[3] = 100;
    
    WiFi.disconnect();
    delay(1000);
    WiFi.config(staticIP, gateway, subnet, dns);
    WiFi.begin(ssid, password);
    
    attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 40) {
      delay(500);
      attempts++;
    }
  }
  
  Serial.print("\nAccess at: http://");
  Serial.println(WiFi.localIP());
  
  server.on("/", handleRoot);
  server.on("/data", handleData);
  server.on("/ml", handleML);
  server.begin();
  
  Serial.println("‚úì ML-powered web server ready!");
}

void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    delay(5000);
    return;
  }
  
  server.handleClient();
  
  // Read sensor and collect data
  static unsigned long lastRead = 0;
  if (millis() - lastRead > 2000) {
    temp = dht.readTemperature();
    hum = dht.readHumidity();
    
    if (!isnan(temp) && !isnan(hum)) {
      addSample(temp, hum);
      runMLAnalysis();
    }
    
    lastRead = millis();
  }
}

void addSample(float t, float h) {
  tempHistory[sampleIndex] = t;
  humHistory[sampleIndex] = h;
  timeHistory[sampleIndex] = millis();
  
  sampleIndex = (sampleIndex + 1) % MAX_SAMPLES;
  if (totalSamples < MAX_SAMPLES) totalSamples++;
}

void runMLAnalysis() {
  if (totalSamples < 10) return;
  
  // Calculate mean
  tempMean = 0;
  humMean = 0;
  for (int i = 0; i < totalSamples; i++) {
    tempMean += tempHistory[i];
    humMean += humHistory[i];
  }
  tempMean /= totalSamples;
  humMean /= totalSamples;
  
  // Calculate standard deviation
  tempStdDev = 0;
  humStdDev = 0;
  for (int i = 0; i < totalSamples; i++) {
    tempStdDev += pow(tempHistory[i] - tempMean, 2);
    humStdDev += pow(humHistory[i] - humMean, 2);
  }
  tempStdDev = sqrt(tempStdDev / totalSamples);
  humStdDev = sqrt(humStdDev / totalSamples);
  
  // Linear regression for trend prediction
  if (totalSamples >= 20) {
    float sumX = 0, sumY_temp = 0, sumY_hum = 0;
    float sumXY_temp = 0, sumXY_hum = 0, sumX2 = 0;
    
    for (int i = 0; i < totalSamples; i++) {
      float x = i;
      sumX += x;
      sumY_temp += tempHistory[i];
      sumY_hum += humHistory[i];
      sumXY_temp += x * tempHistory[i];
      sumXY_hum += x * humHistory[i];
      sumX2 += x * x;
    }
    
    float n = totalSamples;
    float slope_temp = (n * sumXY_temp - sumX * sumY_temp) / (n * sumX2 - sumX * sumX);
    float slope_hum = (n * sumXY_hum - sumX * sumY_hum) / (n * sumX2 - sumX * sumX);
    
    // Convert slope to per-hour rate (samples every 2 seconds)
    tempTrend = slope_temp * 1800;  // 1800 samples = 1 hour
    humTrend = slope_hum * 1800;
    
    // Predict 1 hour ahead
    tempPrediction1h = temp + tempTrend;
    humPrediction1h = hum + humTrend;
  }
  
  // Anomaly Detection (Z-score method)
  tempAnomaly = false;
  humAnomaly = false;
  anomalyMessage = "";
  
  if (totalSamples >= 30) {
    float tempZScore = abs(temp - tempMean) / (tempStdDev + 0.1);
    float humZScore = abs(hum - humMean) / (humStdDev + 0.1);
    
    if (tempZScore > 2.5) {
      tempAnomaly = true;
      anomalyMessage += "Temperature spike detected! ";
    }
    if (humZScore > 2.5) {
      humAnomaly = true;
      anomalyMessage += "Humidity spike detected! ";
    }
  }
  
  // Comfort Index Calculation
  calculateComfort();
}

void calculateComfort() {
  // Heat Index calculation (simplified)
  float heatIndex = temp;
  if (temp >= 27) {
    heatIndex = -8.78 + 1.61*temp + 2.34*hum - 0.14*temp*hum;
  }
  
  comfortScore = 100;
  
  // Temperature comfort (20-26¬∞C is ideal)
  if (temp < 18) comfortScore -= (18 - temp) * 5;
  else if (temp > 26) comfortScore -= (temp - 26) * 5;
  
  // Humidity comfort (40-60% is ideal)
  if (hum < 30) comfortScore -= (30 - hum) * 2;
  else if (hum > 70) comfortScore -= (hum - 70) * 2;
  
  comfortScore = constrain(comfortScore, 0, 100);
  
  if (comfortScore >= 80) comfortLevel = "Excellent";
  else if (comfortScore >= 60) comfortLevel = "Good";
  else if (comfortScore >= 40) comfortLevel = "Fair";
  else if (comfortScore >= 20) comfortLevel = "Poor";
  else comfortLevel = "Uncomfortable";
}

void handleRoot() {
  String html = R"(
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ML Climate Monitor</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      color: white;
      margin-bottom: 10px;
      font-size: 32px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .subtitle {
      text-align: center;
      color: rgba(255,255,255,0.9);
      font-size: 14px;
      margin-bottom: 30px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin-bottom: 20px;
    }
    .card {
      background: white;
      border-radius: 15px;
      padding: 25px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }
    .card-header {
      font-size: 14px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
    }
    .card-icon {
      font-size: 20px;
      margin-right: 8px;
    }
    .card-value {
      font-size: 42px;
      font-weight: bold;
      color: #333;
      margin-bottom: 5px;
    }
    .card-unit {
      font-size: 18px;
      color: #999;
      margin-left: 5px;
    }
    .card-meta {
      font-size: 12px;
      color: #999;
      margin-top: 10px;
    }
    .ml-card {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    }
    .ml-metric {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
      border-bottom: 1px solid rgba(0,0,0,0.1);
    }
    .ml-metric:last-child { border-bottom: none; }
    .ml-label {
      font-size: 13px;
      color: #555;
      font-weight: 600;
    }
    .ml-value {
      font-size: 13px;
      color: #333;
      font-weight: bold;
    }
    .comfort-bar {
      height: 30px;
      background: #e0e0e0;
      border-radius: 15px;
      overflow: hidden;
      margin: 15px 0;
    }
    .comfort-fill {
      height: 100%;
      background: linear-gradient(90deg, #f44336, #ff9800, #4caf50);
      border-radius: 15px;
      transition: width 0.5s;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 10px;
      color: white;
      font-size: 12px;
      font-weight: bold;
    }
    .anomaly {
      background: #fff3cd;
      border-left: 4px solid #ff9800;
      padding: 15px;
      border-radius: 8px;
      margin-top: 20px;
      font-size: 13px;
      color: #856404;
    }
    .trend-up { color: #f44336; }
    .trend-down { color: #2196f3; }
    .trend-stable { color: #4caf50; }
    .badge {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: bold;
      margin-top: 8px;
    }
    .badge-excellent { background: #4caf50; color: white; }
    .badge-good { background: #8bc34a; color: white; }
    .badge-fair { background: #ff9800; color: white; }
    .badge-poor { background: #ff5722; color: white; }
  </style>
</head>
<body>
  <div class="container">
    <h1>ü§ñ ML Climate Monitor</h1>
    <div class="subtitle">Machine Learning Powered Analytics</div>
    
    <div class="grid">
      <div class="card">
        <div class="card-header"><span class="card-icon">üå°Ô∏è</span>Temperature</div>
        <div class="card-value"><span id="temp">--</span><span class="card-unit">¬∞C</span></div>
        <div class="card-meta">
          Mean: <strong id="tempMean">--</strong>¬∞C | 
          Trend: <strong id="tempTrend" class="trend-stable">--</strong>
        </div>
      </div>
      
      <div class="card">
        <div class="card-header"><span class="card-icon">üíß</span>Humidity</div>
        <div class="card-value"><span id="humidity">--</span><span class="card-unit">%</span></div>
        <div class="card-meta">
          Mean: <strong id="humMean">--</strong>% | 
          Trend: <strong id="humTrend" class="trend-stable">--</strong>
        </div>
      </div>
      
      <div class="card ml-card">
        <div class="card-header"><span class="card-icon">üîÆ</span>Predictions (1h)</div>
        <div class="ml-metric">
          <span class="ml-label">Temperature</span>
          <span class="ml-value" id="tempPred">--¬∞C</span>
        </div>
        <div class="ml-metric">
          <span class="ml-label">Humidity</span>
          <span class="ml-value" id="humPred">--%</span>
        </div>
        <div class="ml-metric">
          <span class="ml-label">Samples Collected</span>
          <span class="ml-value" id="samples">--</span>
        </div>
      </div>
    </div>
    
    <div class="card">
      <div class="card-header"><span class="card-icon">üòä</span>Comfort Index</div>
      <div class="comfort-bar">
        <div class="comfort-fill" id="comfortBar" style="width: 0%">
          <span id="comfortScore">0</span>
        </div>
      </div>
      <div style="text-align: center;">
        <span class="badge badge-good" id="comfortBadge">Calculating...</span>
      </div>
    </div>
    
    <div id="anomalyAlert" style="display: none;" class="anomaly">
      ‚ö†Ô∏è <strong>Anomaly Detected:</strong> <span id="anomalyMsg"></span>
    </div>
  </div>

  <script>
    function updateData() {
      Promise.all([
        fetch('/data').then(r => r.json()),
        fetch('/ml').then(r => r.json())
      ]).then(([data, ml]) => {
        // Current readings
        document.getElementById('temp').textContent = data.temperature.toFixed(1);
        document.getElementById('humidity').textContent = data.humidity.toFixed(1);
        
        // ML Analytics
        document.getElementById('tempMean').textContent = ml.tempMean.toFixed(1);
        document.getElementById('humMean').textContent = ml.humMean.toFixed(1);
        document.getElementById('samples').textContent = ml.totalSamples;
        
        // Trends
        const tempTrendEl = document.getElementById('tempTrend');
        const trendT = ml.tempTrend;
        tempTrendEl.textContent = (trendT > 0 ? '+' : '') + trendT.toFixed(2) + '¬∞/h';
        tempTrendEl.className = trendT > 0.5 ? 'trend-up' : (trendT < -0.5 ? 'trend-down' : 'trend-stable');
        
        const humTrendEl = document.getElementById('humTrend');
        const trendH = ml.humTrend;
        humTrendEl.textContent = (trendH > 0 ? '+' : '') + trendH.toFixed(2) + '%/h';
        humTrendEl.className = trendH > 1 ? 'trend-up' : (trendH < -1 ? 'trend-down' : 'trend-stable');
        
        // Predictions
        document.getElementById('tempPred').textContent = ml.tempPrediction.toFixed(1) + '¬∞C';
        document.getElementById('humPred').textContent = ml.humPrediction.toFixed(1) + '%';
        
        // Comfort
        const comfort = ml.comfortScore;
        document.getElementById('comfortScore').textContent = comfort;
        document.getElementById('comfortBar').style.width = comfort + '%';
        
        const badge = document.getElementById('comfortBadge');
        badge.textContent = ml.comfortLevel;
        badge.className = 'badge badge-' + 
          (comfort >= 80 ? 'excellent' : comfort >= 60 ? 'good' : comfort >= 40 ? 'fair' : 'poor');
        
        // Anomalies
        const anomalyDiv = document.getElementById('anomalyAlert');
        if (ml.anomaly && ml.anomalyMessage) {
          document.getElementById('anomalyMsg').textContent = ml.anomalyMessage;
          anomalyDiv.style.display = 'block';
        } else {
          anomalyDiv.style.display = 'none';
        }
      });
    }
    
    updateData();
    setInterval(updateData, 2000);
  </script>
</body>
</html>
  )";
  
  server.send(200, "text/html", html);
}

void handleData() {
  String json = "{";
  json += "\"temperature\":" + String(temp) + ",";
  json += "\"humidity\":" + String(hum);
  json += "}";
  server.send(200, "application/json", json);
}

void handleML() {
  String json = "{";
  json += "\"tempMean\":" + String(tempMean) + ",";
  json += "\"humMean\":" + String(humMean) + ",";
  json += "\"tempStdDev\":" + String(tempStdDev) + ",";
  json += "\"humStdDev\":" + String(humStdDev) + ",";
  json += "\"tempTrend\":" + String(tempTrend) + ",";
  json += "\"humTrend\":" + String(humTrend) + ",";
  json += "\"tempPrediction\":" + String(tempPrediction1h) + ",";
  json += "\"humPrediction\":" + String(humPrediction1h) + ",";
  json += "\"comfortScore\":" + String(comfortScore) + ",";
  json += "\"comfortLevel\":\"" + comfortLevel + "\",";
  json += "\"anomaly\":" + String(tempAnomaly || humAnomaly ? "true" : "false") + ",";
  json += "\"anomalyMessage\":\"" + anomalyMessage + "\",";
  json += "\"totalSamples\":" + String(totalSamples);
  json += "}";
  server.send(200, "application/json", json);
}

